#pragma once
#include "Token.hpp"
#include "AstNodes.hpp"
#include <vector>
#include <memory>
#include <functional>
#include <sstream>

/**
 * CompUnit     ->  [CompUnit] (Decl | FuncDef)
 * Decl         ->  ConstDecl | VarDecl
 * ConstDecl    ->  'const' BType ConstDef {',' ConstDef} ';'
 * BType        ->  'int'
 * ConstDef     ->  Ident {'[' ConstExp ']'} '=' ConstInitVal
 * ConstInitVal ->  ConstExp
 *                  | '{' [ConstInitVal {',' ConstInitVal}] '}'
 * VarDecl      ->  BType VarDef {',' VarDef} ';'
 * VarDef       ->  Ident {'[' ConstExp ']'}
 *                  | Ident {'[' ConstExp ']'} '=' InitVal
 * InitVal      ->  Exp | '{' [InitVal {',' InitVal}] '}'
 * FuncDef      ->  FuncType Ident '(' [FuncFParams] ')' Block
 * FuncType     ->  'void' | 'int'
 * FuncFParams  ->  FuncFParam {',' FuncFParam}
 * FuncFParam   ->  BType Ident ['[' ']' { '[' Exp ']' }]
 * Block        ->  '{' { BlockItem } '}'
 * BlockItem    ->  Decl | Stmt
 * Stmt         ->  LVal '=' Exp ';'
 *                  | [Exp] ';'
 *                  | Block
 *                  | 'if' '( Cond ')' Stmt [ 'else' Stmt ]
 *                  | 'while' '(' Cond ')' Stmt
 *                  | 'break' ';'
 *                  | 'continue' ';'
 *                  | 'return' [Exp] ';'
 * Exp          ->  AddExp 注:SysY 表达式是 int 型表达式
 * Cond         ->  LOrExp
 * LVal         ->  Ident {'[' Exp ']'}
 * PrimaryExp   ->  '(' Exp ')' | LVal | Number
 * Number       ->  IntConst
 * UnaryExp     ->  PrimaryExp
 *                  | Ident '(' [FuncRParams] ')'
 *                  | UnaryOp UnaryExp
 * UnaryOp      ->  '+' | '−' | '!' 注:'!'仅出现在条件表达式中
 * FuncRParams  ->  Exp{','Exp}
 * MulExp       ->  UnaryExp | MulExp ('*' | '/' | '%') UnaryExp
 * AddExp       ->  MulExp | AddExp ('+' | '−') MulExp
 * RelExp       ->  AddExp | RelExp ('<' | '>' | '<=' | '>=') AddExp
 * EqExp        ->  RelExp | EqExp ('==' | '!=') RelExp
 * LAndExp      ->  EqExp | LAndExp '&&' EqExp
 * LOrExp       ->  LAndExp | LOrExp '||' LAndExp
 * ConstExp     ->  AddExp 注:使用的 Ident 必须是常量
 */

class ParsingError {
   public:
    int lineno;
    std::string msg;
    ParsingError(int _lineno, std::string _msg)
        : lineno(_lineno), msg(_msg) {}
};

class Parser {
   public:
    /**
     * @brief Construct a new Parser with tokens
     *
     * @param tokens a vector of tokens generated by Lexer
     */
    Parser(std::vector<Token> tokens);

    /**
     * @brief Reset Parser
     */
    void reset();

    /**
     * @brief Start parsing
     */
    void parse();

    AstNodePtrVector& getCompUnits() { return _compUnits; }

    /**
     * @brief Write AST structure to file
     */
    void outputAst(const std::string &path);

    /**
     * @brief whether parser encountered errors
     */
    bool hasError() const { return _hasError; }

   private:
    /**
     * @brief Construct a ParsingError to throw
     *
     * @param msg error message
     */
    ParsingError error(const std::string& msg);

    /**
     * @brief Construct an AST node
     */
    template <typename T, typename... Args>
    std::unique_ptr<T> makeAstNode(Args&&... args) {
        auto ast = std::make_unique<T>(std::forward<Args>(args)...);
        _astDepth--;
        return ast;
    }

    /**
     * @brief Log an AST node name and lineno to _astLogStream
     *
     * @param str node name
     */
    void logAstNode(std::string_view str);

    /**
     * @brief Log an AST leaf (mostly token) to _astLogStream
     *
     * @param str leaf name
     */
    void logAstLeaf(std::string_view str);

    /**
     * @brief Log a token to _astLogStream with its data when avaliable (id, type, int literals...)
     */
    void logAstToken(const Token& token);

    /**
     * @brief Go next if current token matches type, otherwise an error will be thrown.
     *
     * @param type expected token type
     * @param msg error message
     * @throw ParsingError
     */
    void match(TokenType type, const std::string& msg);

    /**
     * @brief Go next if current token matches type, otherwise an error will be thrown.
     *
     * @param type expected token type
     * @throw ParsingError
     */
    void match(TokenType type);

    /**
     * @brief Whether current tokens matches type. Nothing happens if it does not match.
     *
     * @param type expected token type
     */
    bool tryMatch(TokenType type);

    /**
     * @brief Move token iterator forward.
     */
    void nextToken();

    /**
     * @brief Move token iterator backward.
     */
    void prevToken();

    /**
     * @brief Get current token
     */
    const Token& curToken() const { return *_tokenIter; }

    /**
     * @brief Whether there is a token with 'target' type before parser encounters a token with 'until' type
     *
     * @param target target token type
     * @param until where to end finding
     */
    bool findToken(TokenType target, TokenType until);

    /**
     * @brief Whether current token reaches end of file.
     */
    bool eof() { return _tokenIter == _tokens.end(); }

    /**
     * @brief Whether the next 'distance' token matches any of args.
     *
     * @param distance how many step to move forward
     * @param args token types
     */
    template <class... Args>
    bool tryTokenAhead(int distance, Args... args) {
        auto tempIter = _tokenIter;
        std::advance(_tokenIter, distance);
        auto ret = tryToken(args...);
        _tokenIter = tempIter;
        return ret;
    }

    /**
     * @brief Whether current token matches any of args.
     *
     * @param args token types
     */
    template <class... Args>
    bool tryToken(Args... args) const {
        if ((_tokenIter->is(args) || ...)) return true;
        return false;
    }

#pragma region Parsing functions
    std::string parseID();
    AstCompUnitPtr parseCompUnit();
    AstDeclPtr parseDecl();
    AstNodePtr parseConstDecl();
    AstBTypePtr parseBType();
    AstNodePtr parseConstDef();
    AstNodePtr parseConstInitVal();
    AstVarDeclPtr parseVarDecl();
    AstVarDefPtr parseVarDef();
    AstInitValPtr parseInitVal();
    AstFuncDefPtr parseFuncDef();
    AstFuncTypePtr parseFuncType();
    AstFuncFParamsPtr parseFuncFParams();
    AstFuncFParamPtr parseFuncFParam();
    AstBlockPtr parseBlock();
    AstBlockItemPtr parseBlockItem();
    AstNodePtr parseStmt();
    AstExpPtr parseExp();
    AstNodePtr parseConstExp();
    AstCondPtr parseCond();
    AstLValPtr parseLVal();
    AstPrimaryExpPtr parsePrimaryExp();
    AstNumberPtr parseNumber();
    AstUnaryExpPtr parseUnaryExp();
    AstFuncRParamsPtr parseFuncRParams();
    AstBinaryExpPtr parseMulExp();
    AstBinaryExpPtr parseAddExp();
    AstBinaryExpPtr parseRelExp();
    AstBinaryExpPtr parseEqExp();
    AstBinaryExpPtr parseLAndExp();
    AstBinaryExpPtr parseLOrExp();
    AstFuncCallPtr parseFuncCall();
#pragma endregion

   private:
    std::vector<Token> _tokens;
    std::vector<Token>::iterator _tokenIter;
    std::vector<ParsingError> _errors;
    AstNodePtrVector _compUnits;

    std::stringstream _astLogStream;
    int _astDepth = -1;
    bool _hasError = false;
};
